g = {}
    # This is the genre dictionary. It's intentionally just called "g" because it
    # will be called often while adding genres.
    # Testing

class Genre:
    def __init__ (self, name, sheetname, top_parents, parents, subgenres):
        self.name = name
            # This should always be a string and will always be filled no matter what
        self.sheetname = sheetname
            # These are for genres where part of their name contains a genre name that
            # is not one of their parents. For example, "Ambient Pop" has the word "Ambient"
            # in it even though it does not have "Ambient" as a parent.
            # In such a case, Ambient Pop's sheetname would be "Amb*ent Pop" (see the rules
            # for name modification elsewhere). If there is no modification, then the sheetname
            # should be the exact same as the name

            # TODO: (!) You should have a function you use beforehand that detects the other genre
            # names that are contained within a genre’s name
        self.top_parents = top_parents
            # This should always be a list of nodes, NOT strings
            # This is a list of a genre’s parent genres who are also top-level genres. If it’s
            # a top-level genre (usually meaning it has no parents), it should be inputted
            # as "[Top-level]" though there may be some others in the list

            # TODO: (!) You will have to figure out how to match name strings to nodes since you’re
            # definitely gonna be inputting names and not node objects

            # TODO: (!) I don’t know how this will work yet, but you should also account for things
            # like Metal and EDM which are both top-level genres while still having a parent
            # (Metal has Rock and EDM has Electronic)
        self.parents = parents
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre’s parent genres, including its top parents.
            # 
            # If it’s a top-level genre (usually meaning it has no parents), it should be inputted as
            # “[Top-level]” (again)
            #
            # If it's NOT a top-level genre, you do not need to put "Top-level" as a parent
        self.subgenres = subgenres 
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre's child genres (a.k.a. "subgenres")

            # This INCLUDES the subgenres of its subgenres.
        pass
    
    def back_main(self):
        # This should return a genre’s name along with all of its parents *who are not already*
        # textually contained within the genre’s name, with each genre separated by semicolons
            #These are what I call the “back main” genres
            #For instance, “C86” should return “C86; Indie Pop; Indie Rock; Alt Rock”
            #Before returning it, those four genres should’ve all been compiled in a list beforehand
        
        # Keep in mind that this function is just for finding the back main genres of a single genre.

        # TODO: (!) There should eventually be a function that finds the back main genres of a set of
        # multiple front genres
            # TODO: (!) Define “front genres” some other time for documentation purposes but you
            # already know what they are

        back_main_genres = self.name
            # This is the string which will eventually be returned.
        
        back_main_list = []

        # TODO: (!) You may eventually need to create a function that sorts the genres in self.parents
        # so that the more specific genres come first and the broader genres come last

        for genre in self.parents:
            if genre.name not in self.name and genre.name != 'Top-level':
                back_main_list.append(genre)
                    #This is so there's access to the objects themselves
                back_main_genres += f'; {genre.name}'
            
        return back_main_genres
    
    def back_all(self):
        # This should return a genre’s name along with all of its parents, no matter what, with each
        # genre separated by semicolons

        # TODO: (!) This function.

        pass

    def __str__(self):
        if self.name == self.sheetname:
            return f'{self.name} // Parents: {self.parents}'
        else:
            return f'{self.name} (Sheet Name: {self.sheetname}) // Parents: {self.parents}'

def add_genre(name, sheetname, top_parents, parents):
    if sheetname.lower() == 'n/a':
        sheetname = name
    
    t_pare = []
    pare = []

    for gnr in top_parents:
        t_pare.append(g[f'{gnr}'])
    for gnr in parents:
        pare.append(g[f'{gnr}'])

    subgenres = []
    genr = Genre(name, sheetname, t_pare, pare, subgenres)
    g[f'{name}'] = genr
    if top_parents != '':
        for par in genr.top_parents:
            par.subgenres.append(genr)
        for par in genr.parents:
            if genr not in par.subgenres:
                par.subgenres.append(genr)

def main():
    add_genre('Top-level', '', '', '')
    add_genre('Ambient', 'n/a', ['Top-level'], ['Top-level'])
    add_genre('Space', 'n/a', ['Ambient'], ['Ambient'])
    add_genre('Space Again', 'n/a', ['Ambient'], ['Ambient'])
    print('')
    print(g)
    print('')
    print(g['Space'].back_main())
    for subg in g['Ambient'].subgenres:
        print(subg.name)
    print('')

if __name__ == "__main__":
    main()
    
