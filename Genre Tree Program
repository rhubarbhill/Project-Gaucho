import csv

g = {}
    # This is the genre dictionary. It's intentionally just called "g" because it
    # will be called often while adding genres.
    # Testing

class Genre:
    def __init__ (self, name, sheetname, parents, subgenres):
        self.name = name
            # This should always be a string and will always be filled no matter what
        self.sheetname = sheetname
            # These are for genres where part of their name contains a genre name that
            # is not one of their parents. For example, "Ambient Pop" has the word "Ambient"
            # in it even though it does not have "Ambient" as a parent.
            # In such a case, Ambient Pop's sheetname would be "Amb*ent Pop" (see the rules
            # for name modification elsewhere). If there is no modification, then the sheetname
            # should be the exact same as the name

            # TODO: (!) You should have a function you use beforehand that detects the other genre
            # names that are contained within a genre’s name
        self.parents = parents
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre’s parent genres.
            # 
            # If it’s a top-level genre (usually meaning it has no parents), it should be inputted as
            # “[Top-level]” (again)
            #
            # If it's NOT a top-level genre, you do not need to put "Top-level" as a parent
            # 
            # TODO: (!) I don’t know how this will work yet, but you should also account for things
            # like Metal and EDM which are both top-level genres while still having a parent
            # (Metal has Rock and EDM has Electronic)
        self.subgenres = subgenres 
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre's child genres (a.k.a. "subgenres")

            # This INCLUDES the subgenres of its subgenres.
        pass
    
    def back_main(self, mode):
        # This should return a genre’s name along with all of its parents *who are not already*
        # textually contained within the genre’s name, with each genre separated by semicolons
            #These are what I call the “back main” genres
            #For instance, “C86” should return “C86; Indie Pop; Indie Rock; Alt Rock”
            #Before returning it, those four genres should’ve all been compiled in a list beforehand
        
        # Keep in mind that this function is just for finding the back main genres of a single genre.

        # TODO: (!) Define “front genres” some other time for documentation purposes but you
        # already know what they are

        # TODO: (!) Make a name type parameter to toggle whether it returns names or sheet names

        mode = mode

        back_main_genres = self.sheetname
            # This is the string which will eventually be returned.
        back_main_list = []

        # TODO: (!) You may eventually need to create a function that sorts the genres in self.parents
        # so that the more specific genres come first and the broader genres come last

        for genre in self.parents:
            if genre.name not in self.name and genre.name != 'Top-level':
                back_main_list.append(genre)
                    #This is so there's access to the objects themselves
                back_main_genres += f'; {genre.sheetname}'
        
        if mode == 'obj':
            return back_main_list
        if mode == 'str':
            return back_main_genres
    
    def back_all(self, mode, method):
        # This should return a genre’s name along with all of its parents, no matter what, with each
        # genre separated by semicolons

        # TODO: (!) This function.

        if self.name == 'Top-level' or self.name is None:
            #Base case to stop recursion
            return

        mode = mode
            # Whether it's an object or string
            # 'obj' or 'str'
            # or 'rec', which returns only the object itself.
            # This is necessary for the recursive function to work
        method = method
            # Whether it does it by just returning the list of parents
                # 'par_list'
            # OR by going through each of the parents and doing back_all for each of them
                # 'comp_look' (stands for "comprehensive look")

        back_all_genres = self.name
            # This is the string which will eventually be returned.     
        back_all_list = []
        back_all_list.append(self)

        if method == 'par_list':
            for genre in self.parents:
                if genre.name != 'Top-level':
                    back_all_list.append(genre)
                    back_all_genres += f'; {genre.sheetname}'
        if method == 'comp_look':
            for genre in self.parents:
                back_all_list.append(genre.back_all('obj', 'comp_look'))
                back_all_genres += f'; {genre.back_all("str", "comp_look")}'
            #back_all_genres += f'; {genre.sheetname}'
        
        if mode == 'obj':
            return back_all_list
        if mode == 'str':
            return back_all_genres

        pass

    def back_all_helper(self, par_list, list, string):
        par_list = par_list
        list = list
        string = string

        for genre in par_list:
            if genre.name != 'Top-level':
                list.append(genre)
                string += f'; {genre.sheetname}'
        
        return [list, string]

    # TODO: (!) Make a function that returns the list of subgenres

    def __str__(self):
        parent_strings = []

        for genre in self.parents:
            parent_strings.append(genre.name)

        if self.name == self.sheetname:
            return f'{self.name} // Parents: {parent_strings}'
        else:
            return f'{self.name} (Sheet Name: {self.sheetname}) // Parents: {parent_strings}'

def add_genre(name, sheetname, parents):
    if sheetname.lower() == 'n/a':
        sheetname = name
    
    # TODO: (!) Eventually, it should be possible to input only a genre's immediate
    # parents, and then you can iteratively use back_all on each of those parents
    # so that you can find all of the grandparents just from there

    pare = []

    for gnr in parents:
        pare.append(g[f'{gnr}'])

    subgenres = []
    if f'{name}' not in g:
        genr = Genre(name, sheetname, pare, subgenres)
        #print('Debug: ', genr.name)
        g[f'{name}'] = genr

        if parents != '': #This function is to update the Genre's subgenre list
            for par in genr.parents:
                if genr not in par.subgenres:
                    par.subgenres.append(genr)
    elif f'{name}' in g:
        # TODO: (!) The eventual purpose of this is to make it possible to add a genre again
        # but with new information. If I add a genre that's already been added but I have new
        # information in the "parents" field, then it will add that parent to the list rather
        # than replacing the genre entirely

        # Although it seems redundant, this will eventually coexist with a function that allows
        # you to add or change the parents of a genre. It may also be replaced by that, but
        # for now I'm doing this because the spreadsheet I'm importing from has a lot of
        # duplicate genres that I'd rather not sift through and having a method like this makes
        # it easier to deal with for now.

        #print('Debugging Note: Duplicate')

        genr = g[f'{name}']
        #print('Debug: ', genr.name)

        for gnr in pare:
            if gnr not in genr.parents:
                genr.parents.append(gnr)
        
        if parents != '': #This function is to update the Genre's subgenre list
            for par in genr.parents:
                if genr not in par.subgenres:
                    par.subgenres.append(genr)

        pass

def csv_extract(filename): #Function to add genres from a csv file
    with open(filename, encoding='utf-8') as file:
        csvreader = csv.reader(file)
        for row in csvreader:
            par_gen = [] #To make the list of parent genres
            sheetname = 'n/a'
            if row[0] != row[1]: #If the sheet name (row[1]) is different from the regular name (row[0])
                sheetname = row[1] #Change the sheet name variable to the sheet name
            for gnr in range(2,12): #This is for the columns that have the parent genres
                if row[gnr] != '': #If it's not blank
                    par_gen.append(row[gnr]) #Append the genre to the par_gen list
            add_genre(row[0], sheetname, par_gen)

def print_all_genres():
    #Algorithm to print all genres along with their parents

    print(g['Top-level'].name)
    for subg in g['Top-level'].subgenres:
        print(subg.__str__())
        for subsubg in subg.subgenres:
            print('> ', subsubg.__str__())

    # TODO: (!) Currently, this does technically not print all genres, as it does not
    # print anything with a depth* greater than 2 (like "Flamenco nuevo", which is
    # a subgenre of a subgenre of a subgenre of a... you get the point.) You must
    # eventually make it able to print all genres, which may likely involve recursion.
    #
    # *depth = How deep it is in the genre tree. "Top-level" has a depth of 0,
    # genres like "Pop" and "Rock" have a depth of 1, and and subgenres like "Pop Rock"
    # has a depth of 2, etc.

def print_subgenres(genre):
    genrename = g[f'{genre}'].name
    print(genrename)
    print('')
    print(f'Subgenres of {genrename}:')
    for subgenre in g[f'{genre}'].subgenres:
        print(subgenre.__str__())

def back_main_multiple(genre_list):
    #Enter a list of multiple genres, separated by "; ", and then it will return
    #that list of genres (with their sheet names) plus all of the parents of each one.

    g_list_str = genre_list.split('; ')
    g_list_obj = []
    back_main_genres = ''

    for genre in g_list_str:
        genr = g[f'{genre}']
        g_list_obj.append(genr)

    if len(g_list_str) == 1: #If only one genre is inputted
        back_main_genres = g_list_obj[0].back_main('str')
    elif len(g_list_str) > 1: #If more than one genre is inputted
        back_main_genres += g_list_obj[0].sheetname

        for genre in g_list_obj[1:]:
            back_main_genres += f'; {genre.sheetname}'

        for genre in g_list_obj:
            g_list_2 = genre.back_main('obj')

            for genr in g_list_2:
                if genr.sheetname not in back_main_genres and genre.sheetname != 'Top-level':
                    back_main_genres += f'; {genr.sheetname}'

    return back_main_genres

def main():
    #csv_extract('genres2full.csv')
    csv_extract('genres2softrocktest.csv')

    ##Testing
    #print(g['Spirituals'].back_main('str'))
    #print(g['Spirituals'].back_main('obj'))
    #print('')
    #print(back_main_multiple('Chillwave; Jangle Pop; Country Rock'))
    #print(back_main_multiple('Digital Dancehall'))
    #print('')
    #print_subgenres('Caribbean Music')

    print_all_genres()
    print(g['Soft Rock'].__str__())
    print(g['Softer Rock'].__str__())
    print('')
    print([g['Soft Rock'], g['Pop Rock'], g['Pop'], g['Rock']])
    print('')
    print(g['Soft Rock'].back_all('obj', 'par_list'))
    print(g['Soft Rock'].back_all('str', 'par_list'))
    print('')
    print(g['Soft Rock'].back_all('obj', 'comp_look'))
    print(g['Soft Rock'].back_all('str', 'comp_look'))
    print('')
    print('DIVIDER')
    print('')
    print(g['Softer Rock'].__str__())
    print('')
    print([g['Softer Rock'], g['Soft Rock'], g['Pop Rock'], g['Pop'], g['Rock']])
    print('')
    print(g['Softer Rock'].back_all('obj', 'par_list'))
    print(g['Softer Rock'].back_all('str', 'par_list'))
    print('')
    print(g['Softer Rock'].back_all('obj', 'comp_look'))
    print(g['Softer Rock'].back_all('str', 'comp_look'))
    


if __name__ == "__main__":
    main()
    
