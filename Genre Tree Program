import csv

g = {}
    # This is the genre dictionary. It's intentionally just called "g" because it
    # will be called often while adding genres.
    # Testing

class Genre:
    def __init__ (self, name, sheetname, parents, subgenres):
        self.name = name
            # This should always be a string and will always be filled no matter what
        self.sheetname = sheetname
            # These are for genres where part of their name contains a genre name that
            # is not one of their parents. For example, "Ambient Pop" has the word "Ambient"
            # in it even though it does not have "Ambient" as a parent.
            # In such a case, Ambient Pop's sheetname would be "Amb*ent Pop" (see the rules
            # for name modification elsewhere). If there is no modification, then the sheetname
            # should be the exact same as the name

            # TODO: (!) You should have a function you use beforehand that detects the other genre
            # names that are contained within a genre’s name
        self.parents = parents
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre’s parent genres.
            # 
            # If it’s a top-level genre (usually meaning it has no parents), it should be inputted as
            # “[Top-level]” (again)
            #
            # If it's NOT a top-level genre, you do not need to put "Top-level" as a parent
            # 
            # TODO: (!) I don’t know how this will work yet, but you should also account for things
            # like Metal and EDM which are both top-level genres while still having a parent
            # (Metal has Rock and EDM has Electronic)
        self.subgenres = subgenres 
            # This should always be a list of nodes, NOT name strings
            # This is a list of a genre's child genres (a.k.a. "subgenres")

            # This INCLUDES the subgenres of its subgenres.
        pass
    
    def back_main(self):
        # This should return a genre’s name along with all of its parents *who are not already*
        # textually contained within the genre’s name, with each genre separated by semicolons
            #These are what I call the “back main” genres
            #For instance, “C86” should return “C86; Indie Pop; Indie Rock; Alt Rock”
            #Before returning it, those four genres should’ve all been compiled in a list beforehand
        
        # Keep in mind that this function is just for finding the back main genres of a single genre.

        # TODO: (!) There should eventually be a function that finds the back main genres of a set of
        # multiple front genres
            # TODO: (!) Define “front genres” some other time for documentation purposes but you
            # already know what they are

        back_main_genres = self.name
            # This is the string which will eventually be returned.
        
        back_main_list = []

        # TODO: (!) You may eventually need to create a function that sorts the genres in self.parents
        # so that the more specific genres come first and the broader genres come last

        for genre in self.parents:
            if genre.name not in self.name and genre.name != 'Top-level':
                back_main_list.append(genre)
                    #This is so there's access to the objects themselves
                back_main_genres += f'; {genre.sheetname}'
            
        return back_main_genres
    
    def back_all(self):
        # This should return a genre’s name along with all of its parents, no matter what, with each
        # genre separated by semicolons

        # TODO: (!) This function.

        pass

    # TODO: (!) Make a function that returns the list of subgenres

    def __str__(self):
        parent_strings = []

        for genre in self.parents:
            parent_strings.append(genre.name)

        if self.name == self.sheetname:
            return f'{self.name} // Parents: {parent_strings}'
        else:
            return f'{self.name} (Sheet Name: {self.sheetname}) // Parents: {parent_strings}'

def add_genre(name, sheetname, parents):
    if sheetname.lower() == 'n/a':
        sheetname = name
    
    pare = []

    for gnr in parents:
        pare.append(g[f'{gnr}'])

    subgenres = []
    if f'{name}' not in g:
        genr = Genre(name, sheetname, pare, subgenres)
        #print('Debug: ', genr.name)
        g[f'{name}'] = genr

        if parents != '': #This function is to update the Genre's subgenre list
            for par in genr.parents:
                if genr not in par.subgenres:
                    par.subgenres.append(genr)
    elif f'{name}' in g:
        # TODO: (!) The eventual purpose of this is to make it possible to add a genre again
        # but with new information. If I add a genre that's already been added but I have new
        # information in the "parents" field, then it will add that parent to the list rather
        # than replacing the genre entirely

        # Although it seems redundant, this will eventually coexist with a function that allows
        # you to add or change the parents of a genre. It may also be replaced by that, but
        # for now I'm doing this because the spreadsheet I'm importing from has a lot of
        # duplicate genres that I'd rather not sift through and having a method like this makes
        # it easier to deal with for now.

        #print('Debugging Note: Duplicate')

        genr = g[f'{name}']
        #print('Debug: ', genr.name)

        for gnr in pare:
            if gnr not in genr.parents:
                genr.parents.append(gnr)
        
        if parents != '': #This function is to update the Genre's subgenre list
            for par in genr.parents:
                if genr not in par.subgenres:
                    par.subgenres.append(genr)

        pass

def csv_extract(filename): #Function to add genres from a csv file
    with open(filename, encoding='utf-8') as file:
        csvreader = csv.reader(file)
        for row in csvreader:
            par_gen = [] #To make the list of parent genres
            sheetname = 'n/a'
            if row[0] != row[1]: #If the sheet name (row[1]) is different from the regular name (row[0])
                sheetname = row[1] #Change the sheet name variable to the sheet name
            for gnr in range(2,12): #This is for the columns that have the parent genres
                if row[gnr] != '': #If it's not blank
                    par_gen.append(row[gnr]) #Append the genre to the par_gen list
            add_genre(row[0], sheetname, par_gen)

def print_all_genres():
    #Algorithm to print all genres along with their parents

    print(g['Top-level'].name)
    for subg in g['Top-level'].subgenres:
        print(subg.__str__())
        for subsubg in subg.subgenres:
            print('> ', subsubg.__str__())

    # TODO: (!) Currently, this does technically not print all genres, as it does not
    # print anything with a depth* greater than 2 (like "Flamenco nuevo", which is
    # a subgenre of a subgenre of a subgenre of a... you get the point.)
    #
    # *depth = How deep it is in the genre tree. "Top-level" has a depth of 0,
    # genres like "Pop" and "Rock" have a depth of 1, and and subgenres like "Pop Rock"
    # has a depth of 2, etc.

def main():
    csv_extract('genres2full.csv')

    print(g['Spirituals'].back_main())
    


if __name__ == "__main__":
    main()
    
